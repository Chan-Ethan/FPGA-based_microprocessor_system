// ============================================================
// Screen Init
// ============================================================ 
// Outer_Loop_X50:
@00 00 //READ_FROM_MEM_TO_A 0x03 Load Y value from RAM (starting at 0)
@01 03 
@02 01 //READ_FROM_MEM_TO_B 0x10  // Load X = 50 from RAM
@03 10
@04 03 //WRITE_TO_MEM_FROM_B 0xB0 // Send X = 50 to VGA bus
@05 B0
@06 02 //WRITE_TO_MEM_FROM_A 0xB1 // Send Y to VGA bus
@07 B1
@08 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@09 06
@0A 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@0B B2
@0C 00 //READ_FROM_MEM_TO_A 0x03
@0D 03
@0E 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@0F 02 //WRITE_TO_MEM_FROM_A 0x03 // Store new Y in RAM
@10 03
@11 01 // READ_FROM_MEM_TO_B 0x20 // Load 120 from RAM to B
@12 20
@13 96 //IF_A_EQUALITY_B_GOTO End_Loop_X50 // If Y == 120, exit loop
@14 17 //End_Loop_X50
@15 07 // GOTO Outer_Loop_X50 // Repeat for the next Y value
@16 00 //Outer_Loop_X50
//End_Loop_X50(0x17)

@17 00 // READ_FROM_MEM_TO_A 0x08 //load 0
@18 08 
@19 02 //WRITE_TO_MEM_FROM_A 0x03//reset Y
@1A 03

// Outer_Loop_X110(0x1B):
@1B 00 //READ_FROM_MEM_TO_A 0x03  // Load Y value from RAM (starting at 0)
@1C 03 
@1D 01 //READ_FROM_MEM_TO_B 0x11  // Load X = 110 from RAM
@1E 11
@1F 03 //WRITE_TO_MEM_FROM_B 0xB0 // Send X = 110 to VGA bus
@20 B0
@21 02 //WRITE_TO_MEM_FROM_A 0xB1 // Send Y to VGA bus
@22 B1
@23 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@24 06
@25 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@26 B2
@27 00 //READ_FROM_MEM_TO_A 0x03
@28 03
@29 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@2A 02 //WRITE_TO_MEM_FROM_A 0x03 // Store new Y in RAM
@2B 03
@2C 01 //READ_FROM_MEM_TO_B 0x20 // Load 120 from RAM to B
@2D 20
@2E 96 //IF_A_EQUALITY_B_GOTO End_Loop_X110 // If Y == 120, exit loop
@2F 32 //End_Loop_X110
@30 07 //GOTO Outer_Loop_X110 // Repeat for the next Y value
@31 1B //Outer_Loop_X110
//End_Loop_X110 AND Outer_Loop_Y40 (0x32)

// Loop_Y40
@32 00 //READ_FROM_MEM_TO_A 0x02  // Load X value from RAM (starting at 0)
@33 02 
@34 01 //READ_FROM_MEM_TO_B 0x12  // Load Y = 40 from RAM
@35 12
@36 03 //WRITE_TO_MEM_FROM_B 0xB1 // Send Y = 40 to VGA bus
@37 B1
@38 02 //WRITE_TO_MEM_FROM_A 0xB0 // Send X to VGA bus
@39 B0
@3A 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@3B 06
@3C 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@3D B2
@3E 00 //READ_FROM_MEM_TO_A 0x02
@3F 02
@40 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@41 02 //WRITE_TO_MEM_FROM_A 0x02 // Store new X in RAM
@42 02
@43 01 //READ_FROM_MEM_TO_B 0x21 // Load 160 from RAM to B
@44 21
@45 96 // IF_A_EQUALITY_B_GOTO End_Loop_Y40 // If X == 160, exit loop
@46 49 //End_Loop_Y40
@47 07 //GOTO Outer_Loop_Y40 // Repeat for the next X value
@48 32 //Outer_Loop_Y40
//End_Loop_Y40:(0x49)

@49 00 //READ_FROM_MEM_TO_A 0x08 //load 0
@4A 08 
@4B 02 //WRITE_TO_MEM_FROM_A 0x02//reset X
@4C 02

// Outer_Loop_Y80:(0x4D)
@4D 00 // READ_FROM_MEM_TO_A 0x02
@4E 02 
@4F 01 // READ_FROM_MEM_TO_B 0x13  // Load Y = 80 from RAM
@50 13
@51 03 // WRITE_TO_MEM_FROM_B 0xB1 // Send Y = 80 to VGA bus
@52 B1
@53 02 // WRITE_TO_MEM_FROM_A 0xB0 // Send X to VGA bus
@54 B0
@55 00 // READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@56 06
@57 02 // WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@58 B2
@59 00 // READ_FROM_MEM_TO_A 0x02
@5A 02
@5B 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@5C 02 //WRITE_TO_MEM_FROM_A 0x02 // Store new X in RAM
@5D 02
@5E 01 //READ_FROM_MEM_TO_B 0x21 // Load 160 from RAM to B
@5F 21
@60 96 // IF_A_EQUALITY_B_GOTO End_Loop_Y80 // If X == 160, exit loop
@61 64 // End_Loop_Y80
@62 07 // GOTO Outer_Loop_Y80 // Repeat for the next X value
@63 4D // Outer_Loop_Y80
@64 08 // Jump to IDLE and wait for interrupts
// End_Loop_Y80:(0x64)

// ============================================================
// Mouse interrupt handler’s service routine
// ============================================================
// Control Car according to Mouse position, pseudocode
// if X <= X1: (Branch 1)
//      if Y <= Y1: (Branch 2)
//          Reg[A] = Mem[40] // Move Forward and Left
//          Reg[B] = Mem[50]
//      else if Y <= Y2: (Branch 3)
//          Reg[A] = Mem[43] // Move Left
//          Reg[B] = Mem[53]
//      else (Y > Y2): (Branch 4)
//          Reg[A] = Mem[46] // Move Backward and Left
//          Reg[B] = Mem[56]
// else if X <= X2: (Branch 5)
//      if Y <= Y1: (Branch 6)
//          Reg[A] = Mem[41] // Move Forward
//          Reg[B] = Mem[51]
//      else if Y <= Y2: (Branch 7)
//          Reg[A] = Mem[44] // Keep Idle
//          Reg[B] = Mem[54]
//      else (Y > Y2): (Branch 8)
//          Reg[A] = Mem[47] // Move Backward
//          Reg[B] = Mem[57]
// else (X > X2): (Branch 9)
//      if Y <= Y1: (Branch 10)
//          Reg[A] = Mem[42] // Move Forward and Right
//          Reg[B] = Mem[52]
//      else if Y <= Y2: (Branch 11)
//          Reg[A] = Mem[45] // Move Right
//          Reg[B] = Mem[55]
//      else (Y > Y2): (Branch 12)
//          Reg[A] = Mem[48] // Move Backward and Right
//          Reg[B] = Mem[58]
// IR = Reg[A]
// Seg[1:0] = Reg[B]
// Finish, Go IDLE
// ============================================================
// Control Car according to Mouse position, real machine code
// Branch 1
@65 01 // B <- Mem[0x10] (X1)
@66 10
@67 00 // A <- mouse X position
@68 A1
@69 A6 // if (X > X1) Jump to Branch 5
@6A 87
// else Branch 2
@6B 00 // A <- mouse Y position
@6C A2
@6D 01 // B <- Mem[0x12] (Y1)
@6E 12
@6F A6 // if (Y > Y1) Jump to Branch 3
@70 77
// else, Move Backward and Left
@71 00 // A <- Mem[0x46]
@72 46
@73 01 // B <- Mem[0x56]
@74 56
@75 07 // Jump to Write IR
@76 C1
// Branch 3
@77 01 // B <- Mem[0x13] (Y2)
@78 13
@79 A6 // if (Y > Y2) Jump to Branch 4
@7A 81
// else Move Left
@7B 00 // A <- Mem[0x43]
@7C 43
@7D 01 // B <- Mem[0x53]
@7E 53
@7F 07 // Jump to Write IR
@80 C1
// Branch 4, Move Forward and Left
@81 00 // A <- Mem[0x40]
@82 40
@83 01 // B <- Mem[0x50]
@84 50
@85 07 // Jump to Write IR
@86 C1

// Branch 5
@87 01 // B <- Mem[0x11] (X2)
@88 11
@89 A6 // if (X > X2) Jump to Branch 9
@8A A7
// else Branch 6
@8B 00 // A <- mouse Y position
@8C A2
@8D 01 // B <- Mem[0x12] (Y1)
@8E 12
@8F A6 // if (Y > Y1) Jump to Branch 7
@90 97
// else Move Backward
@91 00 // A <- Mem[0x47]
@92 47
@93 01 // B <- Mem[0x57]
@94 57
@95 07 // Jump to Write IR
@96 C1
// Branch 7
@97 01 // B <- Mem[0x13] (Y2)
@98 13
@99 A6 // if (Y > Y2) Jump to Branch 8
@9A A1
// else Car IDLE
@9B 00 // A <- Mem[0x44]
@9C 44
@9D 01 // B <- Mem[0x54]
@9E 54
@9F 07 // Jump to Write IR
@A0 C1
// Branch 8, Move Forward
@A1 00 // A <- Mem[0x41]
@A2 41
@A3 01 // B <- Mem[0x51]
@A4 51
@A5 07 // Jump to Write IR
@A6 C1

// Branch 9
// Branch 10
@A7 00 // A <- mouse Y position
@A8 A2
@A9 01 // B <- Mem[0x12] (Y1)
@AA 12
@AB A6 // if (Y > Y1) Jump to Branch 11
@AC B3
// else Move Backward and Right
@AD 00 // A <- Mem[0x48]
@AE 48
@AF 01 // B <- Mem[0x58]
@B0 58
@B1 07 // Jump to Write IR
@B2 C1
// Branch 11
@B3 01 // B <- Mem[0x13] (Y2)
@B4 13
@B5 A6 // if (Y > Y2) Jump to Branch 12
@B6 BD
// else Move Right
@B7 00 // A <- Mem[0x45]
@B8 45
@B9 01 // B <- Mem[0x55]
@BA 55
@BB 07 // Jump to Write IR
@BC C1
// Branch 12, Move Forward and Right
@BD 00 // A <- Mem[0x42]
@BE 42
@BF 01 // B <- Mem[0x52]
@C0 52
// Write IR (and seg7)
@C1 02 // IR <- B
@C2 90
@C3 03 // Seg7[1:0] <- B
@C4 D1
@C5 08 // IDLE

// ============================================================
// Timer interrupt handler’s service routine: update pointer
// ============================================================
// Mouse Pointer Update, pseudocode
// if (Prev_X == X1): (Branch 1)
//      Jump to Draw new Pointer
// else if (Prev_X == X2): (Branch 2)
//      Jump to Draw new Pointer
// else if (Prev_Y == Y1): (Branch 3)
//      Jump to Draw new Pointer
// else if (Prev_Y == Y2): (Branch 4)
//      Jump to Draw new Pointer
// else:
//      // Clean Previous pointer on screen
//      VGA_X (0xB0)     = Prev_X (0x30)
//      VGA_Y (0xB1)     = Prev_Y (0x31)
//      VGA_COLOR (0xB2) = background 0 (0x07)
// Draw new Pointer (and save X, Y as Prev_X, Prev_Y)
// VGA_X (0xB0)     = X position (0xA1)
// Prev_X           = X position (0xA1)
// VGA_Y (0xB1)     = Y position (0xA2)
// Prev_Y           = Y position (0xA2)
// VGA_COLOR (0xB2) = foreground 1 (0x06)
// Go IDLE
// ============================================================
// Mouse Pointer Update, real machine code
// Branch 1
@C6 00 // A <- Mem[30] (Previous X position)
@C7 30
@C8 01 // B <- Mem[10] (X1)
@C9 10
@CA 96 // if (Prev_X == X1) Jump to Draw new Pointer
@CB E6
// else Branch 2
@CC 01 // B <- Mem[11] (X2)
@CD 11
@CE 96 // if (Prev_X == X2) Jump to Draw new Pointer
@CF E6
// else Branch 3
@D0 00 // A <- Mem[31] (Previous Y position)
@D1 31
@D2 01 // B <- Mem[12] (Y1)
@D3 12
@D4 96 // if (Prev_Y == Y1) Jump to Draw new Pointer
@D5 E6
// else Branch 4
@D6 01 // B <- Mem[13] (Y2)
@D7 13
@D8 96 // if (Prev_Y == Y1) Jump to Draw new Pointer
@D9 E6
// else clean previous pointer on screen
@DA 00 // A <- Mem[30] (Previous X position)
@DB 30
@DC 02 // VGA_X <- A
@DD B0
@DE 00 // A <- Mem[31] (Previous Y position)
@DF 31
@E0 02 // VGA_Y <- A
@E1 B1
@E2 00 // A <- Mem[07] (background 0)
@E3 07
@E4 02 // VGA_COLOR <- A
@E5 B2
// Draw new Pointer (and save X, Y as Prev_X, Prev_Y)
@E6 00 // A <- Mouse X position
@E7 A1
@E8 02 // VGA_X <- A
@E9 B0
@EA 02 // Prev_X <- A0
@EB 30
@EC 00 // A <- Mouse Y position
@ED A2
@EE 02 // VGA_Y <- A
@EF B1
@F0 02 // Prev_Y <- A0
@F1 31
@F2 00 // A <- Mem[06] (foreground 1)
@F3 06
@F4 02 // VGA_COLOR <- A
@F5 B2
@F6 08 // GO IDLE

// ============================================================
// interrupt handler’s service routine
// ============================================================
@FD F0 // Switches interrupt address, reserved
@FE C0 // Timer interrupt address
@FF 65 // Mouse interrupt address