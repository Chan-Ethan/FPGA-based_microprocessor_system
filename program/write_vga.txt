// ============================================================
// Screen Init
// ============================================================ 
// Outer_Loop_X50:
@00 00 //READ_FROM_MEM_TO_A 0x03 Load Y value from RAM (starting at 0)
@01 03 
@02 01 //READ_FROM_MEM_TO_B 0x10  // Load X = 50 from RAM
@03 10
@04 03 //WRITE_TO_MEM_FROM_B 0xB0 // Send X = 50 to VGA bus
@05 B0
@06 02 //WRITE_TO_MEM_FROM_A 0xB1 // Send Y to VGA bus
@07 B1
@08 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@09 06
@0A 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@0B B2
@0C 00 //READ_FROM_MEM_TO_A 0x03
@0D 03
@0E 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@0F 02 //WRITE_TO_MEM_FROM_A 0x03 // Store new Y in RAM
@10 03
@11 01 // READ_FROM_MEM_TO_B 0x20 // Load 120 from RAM to B
@12 20
@13 96 //IF_A_EQUALITY_B_GOTO End_Loop_X50 // If Y == 120, exit loop
@14 17 //End_Loop_X50
@15 07 // GOTO Outer_Loop_X50 // Repeat for the next Y value
@16 00 //Outer_Loop_X50
//End_Loop_X50(0x17)

@17 00 // READ_FROM_MEM_TO_A 0x08 //load 0
@18 08 
@19 02 //WRITE_TO_MEM_FROM_A 0x03//reset Y
@1A 03

// Outer_Loop_X110(0x1B):
@1B 00
@1C 03 //READ_FROM_MEM_TO_A 0x03  // Load Y value from RAM (starting at 0)
@1D 01 //READ_FROM_MEM_TO_B 0x11  // Load X = 110 from RAM
@1E 11
@1F 03 //WRITE_TO_MEM_FROM_B 0xB0 // Send X = 110 to VGA bus
@20 B0
@21 02 //WRITE_TO_MEM_FROM_A 0xB1 // Send Y to VGA bus
@22 B1
@23 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@24 06
@25 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@26 B2
@27 00 //READ_FROM_MEM_TO_A 0x03
@28 03
@29 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@2A 02 //WRITE_TO_MEM_FROM_A 0x03 // Store new Y in RAM
@2B 03
@2C 01 //READ_FROM_MEM_TO_B 0x20 // Load 120 from RAM to B
@2D 20
@2E 96 //IF_A_EQUALITY_B_GOTO End_Loop_X110 // If Y == 120, exit loop
@2F 32 //End_Loop_X110
@30 07 //GOTO Outer_Loop_X110 // Repeat for the next Y value
@31 1B //Outer_Loop_X110
//End_Loop_X110 AND Outer_Loop_Y40 (0x32)

// Loop_Y40
@32 00 //READ_FROM_MEM_TO_A 0x02  // Load X value from RAM (starting at 0)
@33 02 
@34 01 //READ_FROM_MEM_TO_B 0x12  // Load Y = 40 from RAM
@35 12
@36 03 //WRITE_TO_MEM_FROM_B 0xB1 // Send Y = 40 to VGA bus
@37 B1
@38 02 //WRITE_TO_MEM_FROM_A 0xB0 // Send X to VGA bus
@39 B0
@3A 00 //READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@3B 06
@3C 02 //WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@3D B2
@3E 00 //READ_FROM_MEM_TO_A 0x02
@3F 02
@40 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@41 02 //WRITE_TO_MEM_FROM_A 0x02 // Store new X in RAM
@42 02
@43 01 //READ_FROM_MEM_TO_B 0x21 // Load 160 from RAM to B
@44 21
@45 96 // IF_A_EQUALITY_B_GOTO End_Loop_Y40 // If X == 160, exit loop
@46 49 //End_Loop_Y40
@47 07 //GOTO Outer_Loop_Y40 // Repeat for the next X value
@48 32 //Outer_Loop_Y40
//End_Loop_Y40:(0x49)

@49 00 //READ_FROM_MEM_TO_A 0x08 //load 0
@4A 08 
@4B 02 //WRITE_TO_MEM_FROM_A 0x02//reset X
@4C 02

// Outer_Loop_Y80:(0x4D)
@4D 00 // READ_FROM_MEM_TO_A 0x02
@4E 02 
@4F 01 // READ_FROM_MEM_TO_B 0x13  // Load Y = 80 from RAM
@50 13
@51 03 // WRITE_TO_MEM_FROM_B 0xB1 // Send Y = 80 to VGA bus
@52 B1
@53 02 // WRITE_TO_MEM_FROM_A 0xB0 // Send X to VGA bus
@54 B0
@55 00 // READ_FROM_MEM_TO_A 0x06  // Load the foreground color
@56 06
@57 02 // WRITE_TO_MEM_FROM_A 0xB2 // Send color data to VGA bus
@58 B2
@59 00 // READ_FROM_MEM_TO_A 0x02
@5A 02
@5B 54 //DO_MATHS_OPP_SAVE_IN_A   // A = A + 1
@5C 02 //WRITE_TO_MEM_FROM_A 0x02 // Store new X in RAM
@5D 02
@5E 01 //READ_FROM_MEM_TO_B 0x21 // Load 160 from RAM to B
@5F 21
@60 96 // IF_A_EQUALITY_B_GOTO End_Loop_Y80 // If X == 160, exit loop
@61 64 // End_Loop_Y80
@62 07 // GOTO Outer_Loop_Y80 // Repeat for the next X value
@63 4D // Outer_Loop_Y80
@64 08 // Jump to IDLE and wait for interrupts
// End_Loop_Y80:(0x64)

// ============================================================
// Mouse interrupt handler’s service routine
// ============================================================
// if MODE == 0x00, Read Mouse data repeatly and display it on Seven Segment Display
@00 00 // A <- Mem[0x00]
@01 00
@02 01 // B <- Mem[0x20]
@03 20
@04 96 // if (A == B) Jump to 0x07 
@05 07
// else do nothing
@06 08 // Jump to IDLE if MODE != 00
@07 00 // A <- mouse status
@08 A0
@09 02 // LEDs <- A
@0A C0
@0B 00 // A <- mouse X position
@0C A1
@0D 01 // B <- mouse Y position
@0E A2
@0F 02 // Seg7[3:2] <- A
@10 D0
@11 03 // Seg7[1:0] <- B
@12 D1
// ============================================================
// Control Car according to Mouse position
// if X <= X1:
//      if Y <= Y1:
//          Move Forward and Left
//      else if Y <= Y2:
//          Move Left
//      else (Y > Y2):
//          Move Backward and Left
// else if X <= X2:
//      if Y <= Y1:
//          Move Forward
//      else if Y <= Y2:
//          Keep Idle
//      else (Y > Y2):
//          Move Backward
// else (X > X2):
//      if Y <= Y1:
//          Move Forward and Right
//      else if Y <= Y2:
//          Move Right
//      else (Y > Y2):
//          Move Backward and Right
@

@13 08 // Jump to IDLE and wait for interrupts

// ============================================================
// Slide Switch interrupt handler’s service routine
// ============================================================
// read sw[15:8] to set mode
@20 00 // A <- sw[15:8]
@21 E0
// if (sw[15:8] == 8'b80) Seg7[1:0] <- sw[7:0] (MODE 1)
@22 01 // B <- Mem[0x01]
@23 01
@24 96 // Jump to MODE 1 if (A == B)
@25 30
// else set MODE = 0 (Display Mouse position)
@2A 01 // B <- Mem[0x00]
@2B 00
@2C 03 // Mem[0x20] <- B, Save mode variable 
@2D 20
@2E 07 // Jump to 07 (Mouse)
@2F 07

// MODE 1
@30 02 // Mem[0x20] <- A, Save mode variable 
@31 20
@32 00 // A <- Men[0x00]
@33 00
@34 01 // B <- sw[7:0]
@35 E1
@36 02 // Seg7[3:2] <- A
@37 D0
@38 03 // Seg7[1:0] <- B
@39 D1
@3A 00 // A <- Mem[0x03]
@3B 03
@3C 02 // LEDs <- A
@3D C0
// Send sw[7:0] to IR
@3E 03 // IR <- B
@3F 90
@40 08 // IDLE

// ============================================================
// Timer interrupt handler’s service routine: update pointer
// ============================================================
// if ((X == X1) || (X == X2) || (Y == Y1) || (Y = Y2))
// do nothing
// else
// clean last pointer on screen
// draw new pointer on screen
@60 08 // IDLE

// ============================================================
// interrupt handler’s service routine
// ============================================================
@FD 20 // Switches interrupt address
@FE 60 // Timer interrupt address
@FF 00 // Mouse interrupt address