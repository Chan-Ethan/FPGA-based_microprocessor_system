// WRITE FRAME BUFFER
@00 00 // Read value to regA
@01 00 // regA = HCounter
@02 01 // Read value to regB
@03 01 // regB = constant 159
@04 96 // If HCounter = 159 or not?
@05 0B // Yes, jump to address 0x0B
@06 54 // Else, update A(=HCounter) +=1
@07 02 // Write regA to
@08 00 // regA = HCounter
@09 07 // Goto address
@0A 20 // To Write X Y and Pixel data
@0B 01 // Read value to regB
@0C 04 // regB = constant 119
@0D 00 // Read value to regA
@0E 03 // regA = VCounter
@0F 96 // If VCounter = 119 or not?
@10 1A // Yes, jump to address 0x1A
@11 54 // No, A(=VCounter) +=1
@12 02 // Write regA to
@13 03 // regA = VCounter
@14 00 // Read value to regA
@15 02 // regA = constant 0
@16 02 // Write regA to
@17 00 // HCounter (= 0)
@18 07 // Goto address
@19 20 // To Write X Y and Pixel data
@1A 00 // Read value to regA
@1B 02 // regA = constant 0
@1C 02 // Write regA to
@1D 03 // VCounter = 0 (Finish scan, reset)
@1E 02 // Write regA to
@1F 00 // HCounter = 0
@20 00 // Read value to regA
@21 03 // regA = VCounter
@22 01 // Read value to regB
@23 12 // regB = constant 40
@24 96 // Check if VCounter = 40
@25 30 // Jump to address 0x30
@26 01 // Read value to regB
@27 13 // regB = constant 80
@28 96 // Check if VCounter = 80
@29 30 // Jump to address 0x30
@2A 01 // Read value to regB
@2B 02 // regB = constant 1
@2C 03 // Write regB to
@2D B2 // Address 0xB2
@2E 07 // Goto
@2F 36 // Address 0x36
@30 01 // Read value to regB
@31 05 // regB = constant 0
@32 03 // Write regB to
@33 B2 // Address 0xB2
@34 07 // Goto
@35 4A // Address 0x4A
@36 00 // Read value to regA
@37 00 // regA = HCounter
@38 01 // Read value to regB
@39 10 // regB = constant 53
@3A 96 // Check if HCounter = 53 or not?
@3B 46 // Yes, jump to address 0x46
@3C 01 // Else, read value to regB
@3D 11 // regB = constant 107
@3E 96 // Check if HCounter = 107 or not?
@3F 46 // Yes, jump to address 0x46
@40 01 // Else, Read value to regB
@41 02 // regB = constant 1
@42 03 // Write regB to
@43 B2 // Address 0xB2
@44 07 // Goto
@45 4A // Address 0x4A
@46 01 // Read value to regB
@47 05 // regB = constant 0
@48 03 // Write regB to
@49 B2 // Address 0xB2
@4A 00 // Read value to regA
@4B 00 // regA = HCounter
@4C 02 // Write A to
@4D B0 // Address 0xB0
@4E 01 // Read value to regB
@4F 03 // regB = VCounter
@50 03 // Write regB to
@51 B1 // Address 0xB1
@52 01 // Load max HCounter to B
@53 01
@54 B6 // If curr HCounter less than max
@55 00 // loop again
@56 00 // Load VCounter to A
@57 03
@58 01 // Load max VCounter to B
@59 04
@5A B6 // If curr VCounter less than max
@5B 00 // loop again


// MOUSE INIT
@5C 00 // Read mouse status byte from memory to A
@5D A0
@5E 02 // Store mouse status byte to LED memory
@5F C0
@60 00 // Read prev mouse X position
@61 14
@62 01 // Read prev mouse Y position
@63 15
@64 02 // Write prev mouse X to VGA
@65 B0
@66 03 // Write prev mouse Y to VGA
@67 B1
@68 00 // Load previous pixel value to reg A
@69 16
@6A 02 // Write prev pixel value from reg A to VGA memory high address
@6B B2
@6C 00 // Read Mouse X byte from memory to A
@6D A1
@6E 01 // Read Mouse Y byte from memory to B
@6F A2
@70 02 // Save mouse X to RAM
@71 14
@72 03 // Save mouse Y to RAM
@73 15
@74 02 // Write Mouse X byte to 7-seg memory base address
@75 D0
@76 03 // Write Mouse Y byte to 7-seg memory high address
@77 D1
@78 02 // Write Mouse X byte to VGA memory base address
@79 B0
@7A 03 // Write Mouse Y byte to VGA memory middle address
@7B B1
@7C 00 // Load previous pixel value
@7D B2
@7E 02 // Save previous pixel value to RAM
@7F 16
@80 00 // Load a 1 to reg A
@81 05
@82 02 // Write a 1 from reg A to VGA memory high address
@83 B2
@84 08 // Go to IDLE and wait for interrupts


// DETERMINE WHICH GRID SQUARE
@85 00 // Load mouse X to reg A
@86 A1
@87 01 // Load 53 to reg B
@88 10
@89 B6 // If X is less than 53, branch
@8A 91
@8B 01 // Load 107 to reg B
@8C 11
@8D B6 // If X is less than 107, branch
@8E 9D
@8F 07 // Jump to handling X in the right part of the screen
@90 A9

// X less than 53
@91 00 // Load mouse Y to reg A
@92 A2
@93 01 // Load 40 to reg B
@94 12
@95 B6 // If Y is less than 40, branch to bottom left
@96 B5
@97 01 // Load 80 to reg B
@98 13
@99 B6 // If Y is less than 80, branch to middle left
@9A CD
@9B 07 // Jump to top left
@9C C1

// X between 53 and 107
@9D 00 // Load mouse Y to reg A
@9E A2
@9F 01 // Load 40 to reg B
@A0 12
@A1 B6 // If Y is less than 40, branch to bottom middle
@A2 BD
@A3 01 // Load 80 to reg B
@A4 13
@A5 B6 // If Y is less than 80, branch to middle middle
@A6 D5
@A7 07 // Jump to top middle
@A8 C9

// X over 107
@A9 00 // Load mouse Y to reg A
@AA A2
@AB 01 // Load 40 to reg B
@AC 12
@AD B6 // If Y is less than 40, branch to bottom right
@AE B9
@AF 01 // Load 80 to reg B
@B0 13
@B1 B6 // If Y is less than 80, branch to middle right
@B2 D1
@B3 07 // Jump to top right
@B4 C5


// SELECT DIRECTION
// Bottom left
@B5 00 // Read command from RAM to reg A
@B6 17
@B7 07 // Jump to writing command to IR and LEDs
@B8 D9

// Bottom right
@B9 00 // Read command from RAM to reg A
@BA 18
@BB 07 // Jump to writing command to IR and LEDs
@BC D9

// Bottom middle
@BD 00 // Read command from RAM to reg A
@BE 19
@BF 07 // Jump to writing command to IR and LEDs
@C0 D9

// Top left
@C1 00 // Read command from RAM to reg A
@C2 20
@C3 07 // Jump to writing command to IR and LEDs
@C4 D9

// Top right
@C5 00 // Read command from RAM to reg A
@C6 21
@C7 07 // Jump to writing command to IR and LEDs
@C8 D9

// Top middle
@C9 00 // Read command from RAM to reg A
@CA 22
@CB 07 // Jump to writing command to IR and LEDs
@CC D9

// Middle left
@CD 00 // Read command from RAM to reg A
@CE 23
@CF 07 // Jump to writing command to IR and LEDs
@D0 D9

// Middle right
@D1 00 // Read command from RAM to reg A
@D2 24
@D3 07 // Jump to writing command to IR and LEDs
@D4 D9

// Middle middle
@D5 00 // Read command from RAM to reg A
@D6 25
@D7 07 // Jump to writing command to IR and LEDs
@D8 D9


// WRITE COMMAND TO IR AND LEDS
@D9 02 // Write command from reg A to IR memory
@DA 90
@DB 02 // Write command from reg A to LED memory high address
@DC C1
@DD 08 // Go to IDLE


// INTERRUPT JUMPS
@FE 85 // Timer interrupt address
@FF 5C // Mouse interrupt address