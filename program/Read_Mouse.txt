// Mouse interrupt handler’s service routine
// if MODE == 0x00, Read Mouse data repeatly and display it on Seven Segment Display
@00 00 // A <- Mem[0x00]
@01 00
@02 01 // B <- Mem[0x20]
@03 20
@04 96 // Jump to 0x07 if (A == B)
@05 07
// else do nothing
@06 08 // Jump to IDLE if MODE != 00
@07 00 // A <- mouse status
@08 A0
@09 02 // LEDs <- A
@0A C0
@0B 00 // A <- mouse X position
@0C A1
@0D 01 // B <- mouse Y position
@0E A2
@0F 02 // Seg7[3:2] <- A
@10 D0
@11 03 // Seg7[1:0] <- B
@12 D1
@13 08 // Jump to IDLE and wait for interrupts

// ============================================================
// Slide Switch interrupt handler’s service routine
// read sw[15:8] to set mode
@20 00 // A <- sw[15:8]
@21 E0
// if (sw[15:8] == 8'b80) Seg7[1:0] <- sw[7:0] (MODE 1)
@22 01 // B <- Mem[0x01]
@23 01
@24 96 // Jump to MODE 1 if (A == B)
@25 30
// else if (sw[15:8] == 8'b40) display 0123 on Seg7 (MODE 2)
@26 01 // B <- Mem[0x02]
@27 02
@28 96 // Jump to MODE 2 if (A == B)
@29 40
// else set MODE = 0 (Display Mouse position)
@2A 01 // B <- Mem[0x00]
@2B 00
@2C 03 // Mem[0x20] <- B, Save mode variable 
@2D 20
@2E 08 // IDLE

// MODE 1
@30 02 // Mem[0x20] <- A, Save mode variable 
@31 20
@32 00 // A <- Men[0x00]
@33 00
@34 01 // B <- sw[7:0]
@35 E1
@36 02 // Seg7[3:2] <- A
@37 D0
@38 03 // Seg7[1:0] <- B
@39 D1
@3A 00 // A <- Mem[0x03]
@3B 03
@3C 02 // LEDs <- A
@3D C0
@3E 08 // IDLE

// MODE 2
@40 02 // Mem[0x20] <- A, Save mode variable 
@41 20
@42 00 // A <- Men[0x10]
@43 10
@44 01 // B <- Men[0x11]
@45 11
@46 02 // Seg7[3:2] <- A
@47 D0
@48 03 // Seg7[1:0] <- B
@49 D1
@4A 00 // A <- Mem[0x04]
@4B 04
@4C 02 // LEDs <- A
@4D C0
@4E 08 // IDLE

// ============================================================
// Timer interrupt handler’s service routine
@60 08 // IDLE

// ============================================================
// interrupt handler’s service routine
@FD 20 // Switches interrupt address
@FE 60 // Timer interrupt address
@FF 00 // Mouse interrupt address